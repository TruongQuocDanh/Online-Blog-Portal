// USERS
CREATE TABLE IF NOT EXISTS public.users
(
    user_id bigint NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    username character varying(255) COLLATE pg_catalog."default" NOT NULL,
    email character varying(255) COLLATE pg_catalog."default" NOT NULL,
    password_hash character varying(255) COLLATE pg_catalog."default" NOT NULL,
    role smallint NOT NULL DEFAULT 0,
    display_name character varying(255) COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT users_pkey PRIMARY KEY (user_id),
    CONSTRAINT unique_email UNIQUE (email),
    CONSTRAINT unique_username UNIQUE (username)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.users
    OWNER to postgres;


// POSTS
CREATE TABLE IF NOT EXISTS public.posts
(
    post_id bigint NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    author_id bigint NOT NULL,
    title character varying(255) COLLATE pg_catalog."default" NOT NULL,
    content text COLLATE pg_catalog."default" NOT NULL,
    status smallint NOT NULL DEFAULT 0,
    category character varying(100) COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    published_at timestamp with time zone,
    featured boolean,
    thumbnail_url character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT posts_pkey PRIMARY KEY (post_id),
    CONSTRAINT "FK_author_id" FOREIGN KEY (author_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT chk_posts_status CHECK (status = ANY (ARRAY[0, 1]))
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.posts
    OWNER to postgres;
-- Index: idx_posts_author_id

-- DROP INDEX IF EXISTS public.idx_posts_author_id;

CREATE INDEX IF NOT EXISTS idx_posts_author_id
    ON public.posts USING btree
    (author_id ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: idx_posts_category

-- DROP INDEX IF EXISTS public.idx_posts_category;

CREATE INDEX IF NOT EXISTS idx_posts_category
    ON public.posts USING btree
    (category COLLATE pg_catalog."default" ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: idx_posts_featured

-- DROP INDEX IF EXISTS public.idx_posts_featured;

CREATE INDEX IF NOT EXISTS idx_posts_featured
    ON public.posts USING btree
    (featured ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: idx_posts_status

-- DROP INDEX IF EXISTS public.idx_posts_status;

CREATE INDEX IF NOT EXISTS idx_posts_status
    ON public.posts USING btree
    (status ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;


// POST IMAGES
CREATE TABLE IF NOT EXISTS public.post_images
(
    id bigint NOT NULL DEFAULT nextval('post_images_id_seq'::regclass),
    post_id bigint NOT NULL,
    image_url character varying(255) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT post_images_pkey PRIMARY KEY (id),
    CONSTRAINT fk_post_images_post FOREIGN KEY (post_id)
        REFERENCES public.posts (post_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.post_images
    OWNER to postgres;
-- Index: idx_post_images_post_id

-- DROP INDEX IF EXISTS public.idx_post_images_post_id;

CREATE INDEX IF NOT EXISTS idx_post_images_post_id
    ON public.post_images USING btree
    (post_id ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;


// COMMENTS
CREATE TABLE IF NOT EXISTS public.comments
(
    comment_id bigint NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    post_id bigint NOT NULL,
    user_id bigint NOT NULL,
    content text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    parent_comment_id bigint,
    parent_id bigint,
    CONSTRAINT comments_pkey PRIMARY KEY (comment_id),
    CONSTRAINT "FK_parent_comment_id" FOREIGN KEY (parent_comment_id)
        REFERENCES public.comments (comment_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
        NOT VALID,
    CONSTRAINT "FK_post_id" FOREIGN KEY (post_id)
        REFERENCES public.posts (post_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT "FK_user_id" FOREIGN KEY (user_id)
        REFERENCES public.users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fklri30okf66phtcgbe5pok7cc0 FOREIGN KEY (parent_id)
        REFERENCES public.comments (comment_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.comments
    OWNER to postgres;
-- Index: idx_comments_parent_id

-- DROP INDEX IF EXISTS public.idx_comments_parent_id;

CREATE INDEX IF NOT EXISTS idx_comments_parent_id
    ON public.comments USING btree
    (parent_comment_id ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: idx_comments_post_id

-- DROP INDEX IF EXISTS public.idx_comments_post_id;

CREATE INDEX IF NOT EXISTS idx_comments_post_id
    ON public.comments USING btree
    (post_id ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: idx_comments_user_id

-- DROP INDEX IF EXISTS public.idx_comments_user_id;

CREATE INDEX IF NOT EXISTS idx_comments_user_id
    ON public.comments USING btree
    (user_id ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;